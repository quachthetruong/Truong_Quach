[{"content":"Part 1: Motivation How do we check if something is in a set — fast? The simplest way is a List:\nif x in items: ... But this is O(n) — too slow for large-scale systems.\nA HashSet improves to O(1) lookups on average, but it stores the full elements, requiring more memory than raw data — especially for strings or objects.\nSo what if we trade a little accuracy for massive savings? What if a structure could:\nUse only ~9.6 bits per element (significantly smaller than storing object or string),\nBe wrong only 1% of the time (false positives),\nAnd never say \u0026ldquo;no\u0026rdquo; to something that’s truly there?\nThat’s the power of the Bloom Filter.\nWhere is it used? Bloom filters are quietly at the heart of many systems:\nLSM trees, the foundation of modern NoSQL databases like Apache Cassandra, use Bloom filters to skip disk reads — asking: “Does this file probably contain the key?”\nPlatforms like Quora, Medium, and Yahoo use Bloom filters to:\nPrevent duplicate content,\nAvoid redundant processing,\nSpeed up internal caching systems.\nEven if you don’t see them — Bloom filters are working behind the scenes, making large systems fast and efficient.\nPart 2: What is a false positive? (Definition + Example) What is a false positive? ✅ When you check an element that was inserted, the Bloom filter says “yes” — that’s a true positive, and it’s 100% guaranteed correct.\n⚠️ But sometimes it says “yes” to something that was never inserted — that’s a false positive.\nA false positive happens when a new element matches the bit pattern of others — even though it was never added.\nThe filter sees all bits set and says “Probably yes” — but it’s wrong.\nThat’s the trade-off for speed and space — and you’ll see it clearly in the next example.\nHow does it work? A Bloom filter is built with:\nm: a bit array of length m, all bits start at 0\nk: k independent hash functions\nn: number of elements inserted\nTo insert an element O(1):\nHash it using all k functions\nFlip the corresponding k bits to 1\nTo check membership O(1):\nHash the element using the same k functions\nIf any of the k bits is 0 → the element is definitely not in the set\nIf all are 1 → the element is possibly in the set (could be a false positive)\nExample: When a False Positive Happens Let’s step through a small Bloom filter:\nSetup: m = 10 (bit array of size 10)\nk = 3 hash functions\nInserted elements: \u0026lsquo;apple\u0026rsquo; and \u0026lsquo;banana\u0026rsquo; so n = 2\nStart with an empty bit array:\nInitial: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] Step 1: Insert \u0026lsquo;apple\u0026rsquo; Let’s say:\nh₁(apple) = 2\nh₂(apple) = 4\nh₃(apple) = 7\nUpdate the bit array:\nAfter insert apple: [0, 0, 1, 0, 1, 0, 0, 1, 0, 0] Step 2: Insert \u0026lsquo;banana\u0026rsquo; Let’s say:\nh₁(banana) = 1\nh₂(banana) = 4\nh₃(banana) = 8\nUpdate the bit array:\nAfter insert banana: [0, 1, 1, 0, 1, 0, 0, 1, 1, 0] Step 3: Check \u0026lsquo;banana\u0026rsquo; (True Positive) h₁(banana) = 1 → bit is 1\nh₂(banana) = 4 → bit is 1\nh₃(banana) = 8 → bit is 1\nAll bits are 1 → Bloom filter says “Yes” → ✅ correct!\nStep 4: Check \u0026lsquo;mango\u0026rsquo; (False Positive) h₁(mango) = 2\nh₂(mango) = 4\nh₃(mango) = 7\nCheck bits:\n2 → 1 ✅\n4 → 1 ✅\n7 → 1 ✅\nBloom filter says “Yes”, but \u0026lsquo;mango\u0026rsquo; was never inserted → ❌ false positive\nThis happens because \u0026lsquo;apple\u0026rsquo; and \u0026lsquo;banana\u0026rsquo; already set those bits.\nPart 3: Mathematical Proof Okay — now you understand what a false positive is. Let’s take it a step deeper and explore the probability theory behind Bloom filters.\nDon’t worry — it only uses basic math that every student learns in university. We\u0026rsquo;ll walk through this step-by-step, keeping things intuitive.\nWhat is our goal? We want to answer:\nWhat’s the probability that a new element (not in the set) returns a false positive?\nThat means: all the k bits checked during the query are already 1— even though the element was never inserted, not even once among the n inserted items.\nStep 1: Probability a Bit is Still 0 After One Flip Suppose we have an array of m bits, all starting as 0. Now we flip 1 random bit to 1. The chance that a specific bit stays 0 is:\nWhy? Because we only had a 1/m chance to hit it.\nStep 2: We Perform k × n Bit Flips We insert n elements, each hashed with k functions. So we flip bits k × n times.\nThe probability that a specific bit is still 0 after all those flips is:\nStep 3: Exponential Limit Approximation When m is large and kn is not too huge, we can approximate this with the exponential function:\nThis comes from the identity:\nStep 4: Probability Bit is 1 (i.e. Flipped at Least Once) This tells us how likely a bit is to be 1 after inserting n elements.\nStep 5: False Positive = All k Bits Are 1 Now, suppose we query a new element that wasn’t inserted. Its k hash functions give us k bit positions. The probability that all those k bits are already 1 — just by chance — is:\nAnd that’s the final formula for Bloom filter false positives.\nBloom Filter Example: 1 Million Items (n = 1,000,000) Size per element (m/n) Total Size Hash Functions (k) False Positive Rate 6.25 bits 0.78 MB 4 4.99% 7.5 bits 0.94 MB 5 2.70% 9.58 bits 1.20 MB 6 1.00% 12.5 bits 1.56 MB 8 0.25% Part 4: What’s Next — Other Smart Probabilistic Structures for Big Data Problems Bloom filters solve set membership efficiently — but what about other fundamental questions in computer science?\nHow many unique users have viewed this video? → HyperLogLog\nHow many times did user X access this page? → Count-Min Sketch\nWhat are the 50th, 90th, and 99th percentiles of the measured latencies? → t-digest\nWant more? → Explore more probabilistic data structures.\nReferences: https://www.amazon.com/Probabilistic-Data-Structures-Algorithms-Applications/dp/3748190484 https://en.wikipedia.org/wiki/Category:Probabilistic_data_structures https://brilliant.org/wiki/bloom-filter/ https://redis.io/docs/latest/develop/data-types/probabilistic/ https://en.wikipedia.org/wiki/Bloom_filter ","permalink":"http://localhost:1313/posts/technical/bloom-filters-explained/","summary":"\u003ch2 id=\"part-1-motivation\"\u003ePart 1: Motivation\u003c/h2\u003e\n\u003ch3 id=\"how-do-we-check-if-something-is-in-a-set--fast\"\u003eHow do we check if something is in a set — fast?\u003c/h3\u003e\n\u003cp\u003eThe simplest way is a \u003ccode\u003eList\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e items:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut this is \u003ccode\u003eO(n)\u003c/code\u003e — too slow for large-scale systems.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eHashSet\u003c/code\u003e improves to \u003ccode\u003eO(1)\u003c/code\u003e lookups on average,\nbut it stores the full elements, requiring \u003cstrong\u003emore memory than raw data\u003c/strong\u003e — especially for strings or objects.\u003c/p\u003e\n\u003ch3 id=\"so-what-if-we-trade-a-little-accuracy-for-massive-savings\"\u003eSo what if we trade a little accuracy for massive savings?\u003c/h3\u003e\n\u003cp\u003eWhat if a structure could:\u003c/p\u003e","title":"Bloom Filters Explained: A Fast and Space-Efficient Probabilistic Solution"}]